/**
 * 25. 剪绳子
 * 给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。

每段的绳子的长度记为 k[1]、k[2]、……、k[m]。

k[1]k[2]…k[m] 可能的最大乘积是多少？

例如当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到最大的乘积 18。

样例
输入：8

输出：18
 */

/**
 * 这道题目是数学中一个很经典的问题。
下面我们给出证明：

首先把一个正整数 NN 拆分成若干正整数只有有限种拆法，所以存在最大乘积。
假设 N=n1+n2+…+nkN=n1+n2+…+nk，并且 n1×n2×…×nkn1×n2×…×nk 是最大乘积。

显然1不会出现在其中；
如果对于某个 ii 有 ni≥5ni≥5，那么把 nini 拆分成 3+(ni−3)3+(ni−3)，我们有 3(ni−3)=3ni−9>ni3(ni−3)=3ni−9>ni；
如果 ni=4ni=4，拆成 2+22+2乘积不变，所以不妨假设没有4；
如果有三个以上的2，那么 3×3>2×2×23×3>2×2×2，所以替换成3乘积更大；
综上，选用尽量多的3，直到剩下2或者4时，用2。

时间复杂度分析：当 nn 比较大时，nn 会被拆分成 ⌈n/3⌉⌈n/3⌉ 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 O(n)O(n)。

 */

class Solution {
public:
    int maxProductAfterCutting(int n) {
        if(n <= 3) return 1*(n - 1);
        int res = 1;
        if(n % 3 == 1) res = 4, n -= 4;
        if(n % 3 == 2) res = 2, n -= 2;
        while(n) res*=3, n -= 3;
        
        return res;
    }
};
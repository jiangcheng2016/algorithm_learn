背包问题：
	1.01背包问题		//一件物品只有选和不选两种情况，一种物品只能选一次
	2.完全背包问题		// 每件物品可以选无限次， 爱选多少就选多少，只要背包容量够，就可以一直选
	3.多重背包问题		//每件物品有限制，每个物品选择的上限不同
	4.混合背包问题		//物品有很多种，在混合背包下 最大的价值是多少
	5.二维费用背包问题	// 除了体积外还有重要的限制，类比扩展到N多维
	6.分组背包问题		//先把各种各样物品分成若干组，没组选一件...
	7.背包问题求方案数	//
	8.求背包问题的方案
	9.有依赖的背包问题	//物品不是随便选，有限制

acwing 

2.01背包问题

	有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

	第 i 件物品的体积是 vi，价值是 wi。

	求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
	输出最大价值。

	输入格式
	第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

	接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

	输出格式
	输出一个整数，表示最大价值。

	数据范围
	0<N,V≤1000
	0<vi,wi≤1000
	输入样例
	4 5
	1 2
	2 4
	3 4
	4 5
	输出样例：
	8

思：
	f[i][j] 表示只看前i个物品，总体积J的情况下，总价值最大是多少。

	result = max{f[n][0~v]}

	f[i][j]:
		1.不选第i个物品，f[i][j] = f[i - 1][j];
		2.选第i个物品，f[i][j] = f[i - 1][j - v[i]];
	f[i][j] = max{1.,2.}

	f[0][0] = 0;




#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n,m;
int f[N][N];
int v[N],w[N];

int main()
{
	cin >> n >> m;
	for(int i = 1;i <= n;i ++) cin >> v[i] >> w[i];

	for(int i = 1;i <= n; i ++)
		for(int j = 0;j <= m; j ++)
		{
			f[i][j] = f[i - 1][j];
			if(j >= v[i])
				f[i][j] = max(f[i][j], f[i - 1][j - v[i]]) + w[i];
		}
	int res = 0;
	for (int i = 0; i <= m; i ++) res = max(res, f[n][i]);

	cont << res << endl;
	return 0;
}




























